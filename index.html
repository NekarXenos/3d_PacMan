<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pac-3d -- Power Mode Countdown</title>
    <style>
      /* CSS remains the same as the previous version */
      html,
      body {
        margin: 0; padding: 0; overflow: hidden; background: black; color: white;
        height: 100%; width: 100%; display: flex; align-items: center; justify-content: center;
        user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        overscroll-behavior: none;
      }
      #hud {
        position: absolute; top: 5px; left: 10px; z-index: 12;
        font-family: sans-serif; font-size: 18px; text-shadow: 1px 1px 2px black; color: white;
      }
      canvas { display: block; background: #222; max-width: 100%; max-height: 100%; touch-action: none; }
      .control-button {
        position: fixed; z-index: 10; background-color: rgba(100, 100, 100, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.4); color: white; font-size: 24px; font-weight: bold;
        border-radius: 50%; width: 55px; height: 55px; outline: none; user-select: none;
        -webkit-tap-highlight-color: transparent; display: flex; align-items: center; justify-content: center;
        padding: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: background-color 0.1s ease;
      }
      .control-button:active { background-color: rgba(150, 150, 150, 0.5); }
      #upControl { top: 15px; left: 50%; transform: translateX(-50%); }
      #downControl { bottom: 15px; left: 50%; transform: translateX(-50%); }
      #leftControl { left: 15px; top: 50%; transform: translateY(-50%); }
      #rightControl { right: 15px; top: 50%; transform: translateY(-50%); }
    </style>
  </head>
  <body>
    <!-- HUD is drawn on canvas now for better layering -->
    <!-- <div id="hud">Score: 0 | Lives: 1</div> -->
    <canvas id="gameCanvas"></canvas>

    <!-- On-Screen Buttons -->
    <button id="upControl" class="control-button">↑</button>
    <button id="leftControl" class="control-button">←</button>
    <button id="downControl" class="control-button">↓</button>
    <button id="rightControl" class="control-button">→</button>

    <script>
      // ---------------- Global Constants & Variables ----------------
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let gameWidth;
      let gameHeight;
      let numRays;

      const FOV = Math.PI / 2.5;
      const MAX_DEPTH = 30;
      const MAP_WIDTH = 10;
      const MAP_HEIGHT = 10;

      // --- Movement & Control Constants ---
      const MOVE_SPEED = 2.0;
      const BOOST_FACTOR = 1.75;
      const ROT_SPEED = 2.0;
      const MAX_TAP_TURN_ANGLE_DEG = 45;
      const MAX_TAP_TURN_ANGLE = (MAX_TAP_TURN_ANGLE_DEG * Math.PI) / 180;
      const TAP_DURATION_THRESHOLD = 200;
      const SWIPE_THRESHOLD = 30;
      const CANVAS_SIDE_AREA_RATIO = 0.35;
      const CANVAS_VERTICAL_AREA_RATIO = 0.25;

      // --- Ghost Warning Constants ---
      const GHOST_WARNING_MAX_DISTANCE = 6.0;
      const GHOST_WARNING_PULSE_SPEED = 0.004;
      const GHOST_WARNING_MIN_ALPHA = 0.05;
      const GHOST_WARNING_MAX_ALPHA = 0.35;

      // --- Power Pellet Constants ---
      const POWER_MODE_DURATION = 5000; // 5 seconds in milliseconds
      const POWER_PULSE_SPEED = 0.005;
      const GHOST_EAT_SCORE = 100;

      // --- Colors ---
      const FLOOR_CEILING_EDGE_COLOR = 'rgb(170, 170, 170)'; // Light grey
      const FLOOR_CEILING_HORIZON_COLOR = 'rgb(0, 0, 0)';     // Black
      const POWER_MODE_PULSE_COLOR = 'rgb(255, 255, 0)'; // Yellow
      const HUD_COLOR = 'rgb(255, 255, 255)';
      const POWER_BANNER_COLOR = 'rgb(255, 255, 0)'; // Yellow for banner text

      // --- Image Assets (Embedded) ---
      const pelletImage = new Image(); // (base64 data)
      //pelletImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVBhXY/iPDTBgYGBgYPBf/+8x/D8fCzAwiAEL/x8MDAxMFISBgeG/ffs2w8jIyAQRBPD///8ZoACU//8/pt///z/DkIGBMRgZGTkAUw0A+a8/U0QKKm0AAAAASUVORK5CYII=';
      pelletImage.src = 'images/pellet.png';
      
      const redPelletImage = new Image(); // (base64 data)
      //redPelletImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVBhXY/jPwMAgwsDAwMDw3yTC8P9/BgbGyIAE/P//GRgYpgjC////M/z/nxkYGFhYGN79+w8jIyODCCIAnP//M0ABKP///09hYGBkZAAA/1Y/U96uB+gAAAAASUVORK5CYII=';
      redPelletImage.src = 'images/red_pellet.png';
      
      const ghostImage = new Image(); // (base64 data)
      //ghostImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADdSURBVDhPY/z//z8DNwMDw48GQrC9/v0b////Z8AEwOB/AxgYGBh4DRD/x4aBgeH////MAAbA4H8DGBgYGN4FEvAfGxkYGBgY/v//zAAHwOB/AxgYGBgY3gUS8B8bGfj//zMAA7D4/z8DAwPDf4wAAwPD/v37/w8g8R8+fPgPJIHE//79m4GB4T+IiUEkYDD8Z8AEwOB/AxgYGBgY3gUS8B8bGX78+AEjIyODCCIAnP//M0ABKP///w8DAwMjIyODCCIAnP//M0ABKP///w8DAwMjI4PAfwYA8+EN+1Z0Y8IAAAAASUVORK5CYII=';
      ghostImage.src = 'images/ghost.png';
      
      
      
      // --- Game State ---
      let maze = [];
      let pelletMap = [];
      let player = { x: 1.5, y: 1.5, angle: 0 };
      let ghost = { x: 0, y: 0, angle: 0 };
      let score = 0;
      let lives = 1;
      let remainingPellets = 0;
      let gameState = "playing";
      let bannerMessage = "";
      let bannerStartTime = 0;
      let resetGame = true;
      let showMinimap = false;

      // --- Power Mode State ---
      let isPowerModeActive = false;
      let powerModeStartTime = 0;
      let isGhostDead = false;

      // --- Input State ---
      let keys = {};
      let isBoosting = false;
      let downKeyPressedLastFrame = false;

      // --- Touch State ---
      let activeTouch = { id: null, startX: 0, startY: 0, startTime: 0, currentX: 0, currentY: 0, region: 'none', isHolding: false };

      // ---------------- Utility Functions ----------------
      function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min)) + min; }
      function mod(n, m) { return ((n % m) + m) % m; }
      function wrappedDiff(a, b, size) { let diff = mod(a - b, size); return diff > size / 2 ? diff - size : diff; }
      function interpolateColor(color1, color2, factor) { const r1 = parseInt(color1.substring(1, 3), 16); const g1 = parseInt(color1.substring(3, 5), 16); const b1 = parseInt(color1.substring(5, 7), 16); const r2 = parseInt(color2.substring(1, 3), 16); const g2 = parseInt(color2.substring(3, 5), 16); const b2 = parseInt(color2.substring(5, 7), 16); const r = Math.round(r1 + (r2 - r1) * factor); const g = Math.round(g1 + (g2 - g1) * factor); const b = Math.round(b1 + (b2 - b1) * factor); return `rgb(${r}, ${g}, ${b})`; }
      function rgbToHex(rgbString) { const result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(rgbString); if (!result) return '#000000'; return "#" + ("0" + parseInt(result[1], 10).toString(16)).slice(-2) + ("0" + parseInt(result[2], 10).toString(16)).slice(-2) + ("0" + parseInt(result[3], 10).toString(16)).slice(-2); }

      // ---------------- Maze Generation (No Changes) ----------------
      function generateMaze() { maze = []; for (let y = 0; y < MAP_HEIGHT; y++) { maze[y] = []; for (let x = 0; x < MAP_WIDTH; x++) { maze[y][x] = false; } } const startY = getRandomInt(1, MAP_HEIGHT - 1); let curX = 0; let curY = startY; maze[curY][curX] = true; while (curX < MAP_WIDTH - 1) { let allowed = []; if (curX + 3 <= MAP_WIDTH - 1) { for (let i = 0; i < 2; i++) allowed.push({ dx: 1, dy: 0 }); } else { allowed.push({ dx: 1, dy: 0 }); } if (curX - 3 >= 1) { for (let i = 0; i < 2; i++) allowed.push({ dx: -1, dy: 0 }); } if (curY - 3 >= 1) { for (let i = 0; i < 2; i++) allowed.push({ dx: 0, dy: -1 }); } if (curY + 3 <= MAP_HEIGHT - 2) { for (let i = 0; i < 2; i++) allowed.push({ dx: 0, dy: 1 }); } if (allowed.length === 0) { allowed.push({ dx: 1, dy: 0 }); } const segDir = allowed[getRandomInt(0, allowed.length)]; for (let step = 0; step < 3; step++) { curX += segDir.dx; curY += segDir.dy; if (curY < 0) curY = 0; if (curY >= MAP_HEIGHT) curY = MAP_HEIGHT - 1; maze[curY][curX] = true; if (curX >= MAP_WIDTH - 1) break; } } while (curY < startY) { curY++; maze[curY][curX] = true; } while (curY > startY) { curY--; maze[curY][curX] = true; } maze[startY][MAP_WIDTH - 1] = true; makeSymmetric(); }
      function makeSymmetric() { const N = MAP_WIDTH; const originalMaze = maze.map(row => row.slice()); for (let y = 0; y < N; y++) { for (let x = 0; x < N; x++) { const orbitValues = [originalMaze[N - 1 - y][x], originalMaze[N - 1 - x][y]]; maze[y][x] = orbitValues.some(val => val); } } }

      // ---------------- Pellet Setup (No Changes) ----------------
      function generatePellets() { pelletMap = []; remainingPellets = 0; for (let y = 0; y < MAP_HEIGHT; y++) { pelletMap[y] = []; for (let x = 0; x < MAP_WIDTH; x++) { if (maze[y][x]) { pelletMap[y][x] = { collected: false, type: "normal" }; remainingPellets++; } else { pelletMap[y][x] = null; } } } let redPellets = 0; while (redPellets < 1) { let rx = getRandomInt(0, MAP_WIDTH); let ry = getRandomInt(0, MAP_HEIGHT); if (pelletMap[ry]?.[rx] && pelletMap[ry][rx].type === "normal") { pelletMap[ry][rx].type = "red"; redPellets++; } } }

      // ---------------- Initialization (No Changes) ----------------
      function initGame(resetScore = true, resetLives = true) { generateMaze(); generatePellets(); let pPos = getRandomCorridorCell(); player.x = pPos.x; player.y = pPos.y; player.angle = Math.random() * Math.PI * 2; respawnGhost(); if (resetScore) score = 0; if (resetLives) lives = 1; keys = {}; isBoosting = false; downKeyPressedLastFrame = false; isPowerModeActive = false; powerModeStartTime = 0; isGhostDead = false; resetActiveTouch(); } // Removed updateHUD call, happens in gameLoop now
      function getRandomCorridorCell() { let x, y; do { x = getRandomInt(0, MAP_WIDTH); y = getRandomInt(0, MAP_HEIGHT); } while (!maze[y][x]); return { x: x + 0.5, y: y + 0.5 }; }
      // updateHUD removed, integrated into drawHUD

      // ---------------- Canvas Resizing Logic (No Changes) ----------------
      function resizeCanvas() { const winW = window.innerWidth; const winH = window.innerHeight; const isPortrait = winH > winW; const minRatio = 4 / 3; const maxRatio = 16 / 9; let targetRatio; let availableH = winH; if (isPortrait) { targetRatio = minRatio; availableH = winH * 0.85; } else { const windowRatio = winW / winH; targetRatio = Math.max(minRatio, Math.min(maxRatio, windowRatio)); availableH = winH; } let potentialW = availableH * targetRatio; let potentialH = winW / targetRatio; let newWidth, newHeight; if (potentialW <= winW) { newWidth = potentialW; newHeight = availableH; } else { newWidth = winW; newHeight = potentialH; } newWidth = Math.min(newWidth, winW); newHeight = Math.min(newHeight, winH); canvas.width = Math.floor(newWidth); canvas.height = Math.floor(newHeight); gameWidth = canvas.width; gameHeight = canvas.height; numRays = gameWidth; }

      // ---------------- Raycasting Engine (No Changes) ----------------
      function castRays(currentTime) { ctx.clearRect(0, 0, gameWidth, gameHeight); let edgeColor = FLOOR_CEILING_EDGE_COLOR; if (isPowerModeActive) { const elapsedPowerTime = currentTime - powerModeStartTime; const pulseFactor = (Math.sin(elapsedPowerTime * POWER_PULSE_SPEED) + 1) / 2; edgeColor = interpolateColor(rgbToHex(FLOOR_CEILING_EDGE_COLOR), rgbToHex(POWER_MODE_PULSE_COLOR), pulseFactor); } const ceilingGradient = ctx.createLinearGradient(0, 0, 0, gameHeight / 2); ceilingGradient.addColorStop(0, edgeColor); ceilingGradient.addColorStop(1, FLOOR_CEILING_HORIZON_COLOR); ctx.fillStyle = ceilingGradient; ctx.fillRect(0, 0, gameWidth, gameHeight / 2); const floorGradient = ctx.createLinearGradient(0, gameHeight / 2, 0, gameHeight); floorGradient.addColorStop(0, FLOOR_CEILING_HORIZON_COLOR); floorGradient.addColorStop(1, edgeColor); ctx.fillStyle = floorGradient; ctx.fillRect(0, gameHeight / 2, gameWidth, gameHeight / 2); for (let x = 0; x < numRays; x++) { const rayAngle = player.angle - FOV / 2 + (x / numRays) * FOV; let rayX = player.x; let rayY = player.y; const rayDirX = Math.cos(rayAngle); const rayDirY = Math.sin(rayAngle); let distanceToWall = 0; let hitWall = false; let hitBoundary = false; while (!hitWall && distanceToWall < MAX_DEPTH) { distanceToWall += 0.05; let testX = Math.floor(mod(rayX + rayDirX * distanceToWall, MAP_WIDTH)); let testY = Math.floor(mod(rayY + rayDirY * distanceToWall, MAP_HEIGHT)); if (!maze[testY][testX]) { hitWall = true; let prevTestX = Math.floor(mod(rayX + rayDirX * (distanceToWall - 0.05), MAP_WIDTH)); let prevTestY = Math.floor(mod(rayY + rayDirY * (distanceToWall - 0.05), MAP_HEIGHT)); if (testX !== prevTestX) { hitBoundary = (testX === 0 || testX === MAP_WIDTH - 1); } else if (testY !== prevTestY) { hitBoundary = (testY === 0 || testY === MAP_HEIGHT - 1); } } } const correctedDistance = distanceToWall * Math.cos(rayAngle - player.angle); const lineHeight = Math.floor(gameHeight / correctedDistance); let wallColor; let shade = Math.max(0, 255 - correctedDistance * 15); if (hitBoundary) { const greenComp = Math.floor(shade * 0.8); const blueComp = Math.floor(shade * 0.8); wallColor = `rgb(0, ${greenComp}, ${blueComp})`; } else { wallColor = `rgb(${shade}, ${shade}, ${shade})`; } ctx.fillStyle = wallColor; const lineX = x; const lineY = (gameHeight - lineHeight) / 2; ctx.fillRect(lineX, lineY, 1, lineHeight); } }

      // ---------------- Player Update (No Changes) ----------------
      function updatePlayer(dt) { if (gameState !== "playing") return; let currentRotSpeed = 0; let currentMoveSpeed = MOVE_SPEED; let trigger180Turn = false; if (activeTouch.id !== null && activeTouch.isHolding) { switch (activeTouch.region) { case 'left': currentRotSpeed = -ROT_SPEED; break; case 'right': currentRotSpeed = ROT_SPEED; break; case 'top': isBoosting = true; break; } } if (keys.ArrowLeft) currentRotSpeed = -ROT_SPEED; if (keys.ArrowRight) currentRotSpeed = ROT_SPEED; if (keys.ArrowUp) isBoosting = true; if (keys.ArrowDown && !downKeyPressedLastFrame) { trigger180Turn = true; } downKeyPressedLastFrame = keys.ArrowDown; if (currentRotSpeed !== 0) { player.angle += currentRotSpeed * dt; player.angle = mod(player.angle, Math.PI * 2); } if (trigger180Turn) { player.angle = mod(player.angle + Math.PI, Math.PI * 2); isBoosting = false; if (activeTouch.id !== null) resetActiveTouch(); } if (isBoosting) { currentMoveSpeed *= BOOST_FACTOR; } let moveStep = currentMoveSpeed * dt; let newX = mod(player.x + Math.cos(player.angle) * moveStep, MAP_WIDTH); let newY = mod(player.y + Math.sin(player.angle) * moveStep, MAP_HEIGHT); if (maze[Math.floor(newY)][Math.floor(newX)]) { player.x = newX; player.y = newY; } else { let slideX = mod(player.x + Math.cos(player.angle) * moveStep, MAP_WIDTH); if (maze[Math.floor(player.y)][Math.floor(slideX)]) { player.x = slideX; } else { let slideY = mod(player.y + Math.sin(player.angle) * moveStep, MAP_HEIGHT); if (maze[Math.floor(slideY)][Math.floor(player.x)]) { player.y = slideY; } } } isBoosting = false; let cellX = Math.floor(player.x); let cellY = Math.floor(player.y); if (pelletMap[cellY]?.[cellX] && !showMinimap && !pelletMap[cellY][cellX].collected) { pelletMap[cellY][cellX].collected = true; if (pelletMap[cellY][cellX].type === "red") { isPowerModeActive = true; powerModeStartTime = performance.now(); isGhostDead = false; } else { score += 10; } remainingPellets--; if (remainingPellets === 0) { gameState = "banner"; bannerMessage = `LEVEL CLEAR! Score: ${score}`; bannerStartTime = performance.now(); resetGame = false; } } if (!isGhostDead && Math.floor(player.x) === Math.floor(ghost.x) && Math.floor(player.y) === Math.floor(ghost.y)) { if (isPowerModeActive) { score += GHOST_EAT_SCORE; isGhostDead = true; } else { lives--; if (lives <= 0) { gameState = "banner"; bannerMessage = `GAME OVER | Score: ${score}`; bannerStartTime = performance.now(); resetGame = true; } else { gameState = "banner"; bannerMessage = `CAUGHT! Lives: ${lives}`; bannerStartTime = performance.now(); resetGame = false; } } } }

      // ---------------- Ghost Update (No Changes) ----------------
      function updateGhost(dt) { if (isGhostDead || gameState !== "playing") return; if (Math.random() < 0.02) { ghost.angle = Math.random() * Math.PI * 2; } const ghostSpeed = MOVE_SPEED * 0.75; let moveStep = ghostSpeed * dt; let newX = mod(ghost.x + Math.cos(ghost.angle) * moveStep, MAP_WIDTH); let newY = mod(ghost.y + Math.sin(ghost.angle) * moveStep, MAP_HEIGHT); if (maze[Math.floor(newY)][Math.floor(newX)]) { ghost.x = newX; ghost.y = newY; } else { ghost.angle = Math.random() * Math.PI * 2; } }

      // ---------------- Ghost Respawn Function (No Changes) ----------------
      function respawnGhost() { let gPos; let pCellX = Math.floor(player.x); let pCellY = Math.floor(player.y); let attempts = 0; do { gPos = getRandomCorridorCell(); attempts++; } while (attempts < 20 && Math.abs(gPos.x - player.x) < 3 && Math.abs(gPos.y - player.y) < 3); ghost.x = gPos.x; ghost.y = gPos.y; ghost.angle = Math.random() * Math.PI * 2; isGhostDead = false; }

      // ---------------- Sprite Drawing (No Changes) ----------------
      function drawSprites() { let spritesToDraw = []; for (let y = 0; y < MAP_HEIGHT; y++) { for (let x = 0; x < MAP_WIDTH; x++) { if (pelletMap[y]?.[x] && !pelletMap[y][x].collected) { processSprite(x + 0.5, y + 0.5, pelletMap[y][x].type === 'red' ? redPelletImage : pelletImage, 0.3, spritesToDraw, 'pellet'); } } } if (!isGhostDead) { processSprite(ghost.x, ghost.y, ghostImage, 0.6, spritesToDraw, 'ghost'); } spritesToDraw.sort((a, b) => b.distance - a.distance); for (let sprite of spritesToDraw) { if (sprite.image.complete && sprite.image.naturalWidth !== 0) { let drawX = sprite.screenX - sprite.screenSize / 2; let drawY; const floorLevel = gameHeight / 2; const perspectiveFactor = gameHeight / (2 * sprite.distance * Math.cos(sprite.relativeAngle)); if (sprite.type === 'pellet') { drawY = floorLevel + perspectiveFactor * 0.2 - sprite.screenSize / 2; } else { drawY = floorLevel + perspectiveFactor * 0.1 - sprite.screenSize / 1.5; } drawY = Math.max(0, Math.min(gameHeight - sprite.screenSize, drawY)); ctx.drawImage(sprite.image, drawX, drawY, sprite.screenSize, sprite.screenSize); } } }
      function processSprite(spriteX, spriteY, image, baseSize, spritesToDraw, type) { const RAY_STEP = 0.05; let dx = wrappedDiff(spriteX, player.x, MAP_WIDTH); let dy = wrappedDiff(spriteY, player.y, MAP_HEIGHT); let distance = Math.sqrt(dx * dx + dy * dy); if (distance < 0.1) return; let angleToSprite = Math.atan2(dy, dx); let relativeAngle = mod(angleToSprite - player.angle + Math.PI, 2 * Math.PI) - Math.PI; if (Math.abs(relativeAngle) <= FOV / 2 + 0.1) { let isVisible = true; const rayDirX = Math.cos(angleToSprite); const rayDirY = Math.sin(angleToSprite); let currentDist = RAY_STEP; while (currentDist < distance) { let checkX = mod(player.x + rayDirX * currentDist, MAP_WIDTH); let checkY = mod(player.y + rayDirY * currentDist, MAP_HEIGHT); if (!maze[Math.floor(checkY)][Math.floor(checkX)]) { isVisible = false; break; } currentDist += RAY_STEP; } if (isVisible) { const projectionFactor = (gameWidth / 2) / Math.tan(FOV / 2); let screenX = (gameWidth / 2) + Math.tan(relativeAngle) * projectionFactor; let screenSize = (baseSize * projectionFactor) / (distance * Math.cos(relativeAngle)); spritesToDraw.push({ screenX: screenX, screenSize: Math.max(1, screenSize), distance: distance, image: image, type: type, relativeAngle: relativeAngle }); } } }

      // ---------------- Ghost Warning Overlay Drawing (No Changes) ----------------
      function drawGhostWarningOverlay(currentTime) { if (isGhostDead || gameState !== 'playing') return; const dx = wrappedDiff(ghost.x, player.x, MAP_WIDTH); const dy = wrappedDiff(ghost.y, player.y, MAP_HEIGHT); const distance = Math.sqrt(dx * dx + dy * dy); const angleToGhost = Math.atan2(dy, dx); const relativeAngle = mod(angleToGhost - player.angle + Math.PI, 2 * Math.PI) - Math.PI; const isBehind = Math.abs(relativeAngle) > Math.PI / 1.9; if (isBehind && distance < GHOST_WARNING_MAX_DISTANCE && distance > 0.1) { const intensity = Math.max(0, Math.min(1, 1.0 - (distance / GHOST_WARNING_MAX_DISTANCE))); const pulseFactor = (Math.sin(currentTime * GHOST_WARNING_PULSE_SPEED) + 1) / 2; const finalAlpha = intensity * (GHOST_WARNING_MIN_ALPHA + pulseFactor * (GHOST_WARNING_MAX_ALPHA - GHOST_WARNING_MIN_ALPHA)); ctx.save(); ctx.fillStyle = `rgba(200, 0, 0, ${finalAlpha})`; ctx.globalAlpha = finalAlpha; ctx.fillRect(0, 0, gameWidth, gameHeight); ctx.restore(); } }

      // ---------------- HUD and Banner Drawing ----------------

      function drawHUD() {
          ctx.save();
          ctx.font = "18px sans-serif";
          ctx.fillStyle = HUD_COLOR;
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          // Add shadow for readability
          ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
          ctx.shadowBlur = 3;
          ctx.shadowOffsetX = 1;
          ctx.shadowOffsetY = 1;
          ctx.fillText(`Score: ${score} | Lives: ${lives}`, 10, 5);
          ctx.restore();
      }

      function drawPowerModeBanner(currentTime) {
          if (!isPowerModeActive || gameState !== 'playing') return;

          const elapsed = currentTime - powerModeStartTime;
          const remainingMillis = Math.max(0, POWER_MODE_DURATION - elapsed);
          const remainingSeconds = Math.ceil(remainingMillis / 1000);

          ctx.save();
          // Banner Text
          const bannerFontSize = Math.max(18, Math.min(30, Math.floor(gameWidth / 25)));
          ctx.font = `bold ${bannerFontSize}px sans-serif`;
          ctx.fillStyle = POWER_BANNER_COLOR;
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;
          const bannerText = "Catch the ghost now!";
          const bannerY = 5; // Position near top
          ctx.fillText(bannerText, gameWidth / 2, bannerY);

          // Countdown Timer Text
          const timerFontSize = Math.max(24, Math.min(48, Math.floor(gameWidth / 15)));
          ctx.font = `bold ${timerFontSize}px sans-serif`;
          // Optional: Change color in last second?
          // ctx.fillStyle = remainingSeconds <= 1 ? 'red' : POWER_BANNER_COLOR;
          const timerY = bannerY + bannerFontSize + 5; // Position below banner text
          ctx.fillText(`${remainingSeconds}`, gameWidth / 2, timerY);

          ctx.restore();
      }

      function drawGameEndBanner(message) { // Renamed from drawBanner
          ctx.save();
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, gameWidth, gameHeight);
          ctx.fillStyle = "white";
          const fontSize = Math.max(24, Math.min(48, Math.floor(gameWidth / 20)));
          ctx.font = `${fontSize}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 5;
          ctx.fillText(message, gameWidth / 2, gameHeight / 2);
          ctx.restore();
      }

      // ---------------- Main Game Loop (Call new Draw functions) ----------------
      let lastTime = 0;
      function gameLoop(currentTime) {
          if (!lastTime) lastTime = currentTime;
          let dt = (currentTime - lastTime) / 1000;
          lastTime = currentTime;
          dt = Math.min(dt, 0.1);

          // --- Power Mode Timeout Check ---
          if (isPowerModeActive && (currentTime - powerModeStartTime >= POWER_MODE_DURATION)) {
              isPowerModeActive = false;
              if (isGhostDead) { respawnGhost(); }
          }

          // --- Updates ---
          if (gameState === "playing") {
              updatePlayer(dt);
              updateGhost(dt);
          }

          // --- Drawing ---
          castRays(currentTime);
          drawSprites();
          drawGhostWarningOverlay(currentTime);
          drawMinimap();
          drawHUD(); // Draw score/lives HUD
          drawPowerModeBanner(currentTime); // Draw power mode banner/timer if active

          // --- Game End Banner Logic ---
          if (gameState === "banner") {
              drawGameEndBanner(bannerMessage); // Use specific function
              if (currentTime - bannerStartTime >= 1500) {
                  if (resetGame) { initGame(true, true); }
                  else if (lives > 0 && remainingPellets === 0) { initGame(false, false); }
                  else if (lives > 0) {
                       let pPos = getRandomCorridorCell(); player.x = pPos.x; player.y = pPos.y; player.angle = Math.random() * Math.PI * 2;
                       respawnGhost();
                  }
                  gameState = "playing";
              }
          }
          requestAnimationFrame(gameLoop);
      }

      // ---------------- Minimap Drawing (No Changes) ----------------
      function drawMinimap() { if (!showMinimap) return; const mapAreaSize = Math.min(gameWidth, gameHeight) * 0.25; const scale = Math.floor(mapAreaSize / Math.max(MAP_WIDTH, MAP_HEIGHT)); const mapOffsetX = 10; const mapOffsetY = 40; /* Adjusted Y offset for HUD */ if (scale < 1) return; ctx.save(); ctx.fillStyle = "rgba(50, 50, 50, 0.7)"; ctx.fillRect(mapOffsetX - 2, mapOffsetY - 2, MAP_WIDTH * scale + 4, MAP_HEIGHT * scale + 4); for (let y = 0; y < MAP_HEIGHT; y++) { for (let x = 0; x < MAP_WIDTH; x++) { ctx.fillStyle = maze[y][x] ? "#AAA" : "#333"; ctx.fillRect(mapOffsetX + x * scale, mapOffsetY + y * scale, scale, scale); if (pelletMap[y]?.[x] && !pelletMap[y][x].collected) { ctx.fillStyle = pelletMap[y][x].type === "red" ? "red" : "lightblue"; ctx.fillRect(mapOffsetX + x * scale + scale * 0.3, mapOffsetY + y * scale + scale * 0.3, scale * 0.4, scale * 0.4); } } } ctx.fillStyle = "yellow"; ctx.fillRect(mapOffsetX + player.x * scale - scale * 0.25, mapOffsetY + player.y * scale - scale * 0.25, scale * 0.5, scale * 0.5); if (!isGhostDead) { ctx.fillStyle = "magenta"; ctx.fillRect(mapOffsetX + ghost.x * scale - scale * 0.25, mapOffsetY + ghost.y * scale - scale * 0.25, scale * 0.5, scale * 0.5); } ctx.restore(); }

      // ---------------- Input Handlers (No Changes) ----------------
      // --- Keyboard Handlers ---
      window.addEventListener("keydown", (e) => { keys[e.key] = true; if (e.key === "m" || e.key === "M") showMinimap = !showMinimap; if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) { e.preventDefault(); } });
      window.addEventListener("keyup", (e) => { keys[e.key] = false; if (e.key === 'ArrowDown') { downKeyPressedLastFrame = false; } });
      // --- Mobile Control Button Linker ---
      function addControlListener(buttonId, keyName) { const button = document.getElementById(buttonId); if (!button) return; button.addEventListener("touchstart", (e) => { e.preventDefault(); keys[keyName] = true; }, { passive: false }); button.addEventListener("mousedown", (e) => { e.preventDefault(); keys[keyName] = true; }); button.addEventListener("touchend", (e) => { e.preventDefault(); keys[keyName] = false; }); button.addEventListener("mouseup", (e) => { e.preventDefault(); keys[keyName] = false; }); button.addEventListener("touchcancel", (e) => { e.preventDefault(); keys[keyName] = false; }); button.addEventListener("mouseleave", (e) => { if(e.buttons !== 1) keys[keyName] = false; }); }
      addControlListener("upControl", "ArrowUp"); addControlListener("downControl", "ArrowDown"); addControlListener("leftControl", "ArrowLeft"); addControlListener("rightControl", "ArrowRight");
      // --- Canvas Touch Handlers ---
      function getTouchRegion(x, y) { const rect = canvas.getBoundingClientRect(); const relativeX = x - rect.left; const relativeY = y - rect.top; const canvasW = rect.width; const canvasH = rect.height; const sideWidth = canvasW * CANVAS_SIDE_AREA_RATIO; const verticalHeight = canvasH * CANVAS_VERTICAL_AREA_RATIO; if (relativeY < verticalHeight) return 'top'; if (relativeY > canvasH - verticalHeight) return 'bottom'; if (relativeX < sideWidth) return 'left'; if (relativeX > canvasW - sideWidth) return 'right'; return 'center'; }
      function resetActiveTouch() { activeTouch.id = null; activeTouch.region = 'none'; activeTouch.isHolding = false; }
      canvas.addEventListener("touchstart", (e) => { e.preventDefault(); if (activeTouch.id === null && e.changedTouches.length > 0) { const touch = e.changedTouches[0]; activeTouch.id = touch.identifier; activeTouch.startX = touch.pageX; activeTouch.startY = touch.pageY; activeTouch.currentX = touch.pageX; activeTouch.currentY = touch.pageY; activeTouch.startTime = performance.now(); activeTouch.region = getTouchRegion(touch.clientX, touch.clientY); activeTouch.isHolding = true; } }, { passive: false });
      canvas.addEventListener("touchmove", (e) => { e.preventDefault(); if (activeTouch.id !== null) { for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (touch.identifier === activeTouch.id) { activeTouch.currentX = touch.pageX; activeTouch.currentY = touch.pageY; break; } } } }, { passive: false });
      function handleTouchEnd(touch) { if (touch.identifier !== activeTouch.id) return; const touchEndX = touch.pageX; const touchEndY = touch.pageY; const deltaX = touchEndX - activeTouch.startX; const deltaY = touchEndY - activeTouch.startY; const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); const duration = performance.now() - activeTouch.startTime; const region = activeTouch.region; if (duration < TAP_DURATION_THRESHOLD && distance < SWIPE_THRESHOLD) { if (region === 'bottom') { player.angle = mod(player.angle + Math.PI, Math.PI * 2); } else if (region === 'left' || region === 'right') { const rect = canvas.getBoundingClientRect(); const tapX = touch.clientX - rect.left; const normalizedX = (tapX / rect.width) * 2 - 1; const turnAmount = normalizedX * MAX_TAP_TURN_ANGLE; player.angle += turnAmount; player.angle = mod(player.angle, Math.PI * 2); } } else if (distance >= SWIPE_THRESHOLD) { if (Math.abs(deltaY) > Math.abs(deltaX)) { if (deltaY > 0) { player.angle = mod(player.angle + Math.PI, Math.PI * 2); } } } resetActiveTouch(); }
      canvas.addEventListener("touchend", (e) => { e.preventDefault(); if (activeTouch.id !== null) { for (let i = 0; i < e.changedTouches.length; i++) { handleTouchEnd(e.changedTouches[i]); } } }, { passive: false });
      canvas.addEventListener("touchcancel", (e) => { e.preventDefault(); if (activeTouch.id !== null) { for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === activeTouch.id) { resetActiveTouch(); break; } } } }, { passive: false });
      canvas.addEventListener('contextmenu', e => e.preventDefault());

      // ---------------- Start the Game ----------------
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      initGame();
      requestAnimationFrame(gameLoop);

    </script>
  </body>
</html>