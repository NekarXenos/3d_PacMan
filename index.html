<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Ensure proper viewport scaling on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pac-3d -- Retro Raycaster Maze Game</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        color: white;
        height: 100%;
        width: 100%;
        /* Use Flexbox to center the canvas */
        display: flex;
        align-items: center; /* Vertical center */
        justify-content: center; /* Horizontal center */
      }
      #hud {
        position: absolute;
        top: 5px;
        left: 10px;
        z-index: 2;
        font-family: sans-serif;
        font-size: 18px;
        /* Ensure HUD is readable on any background */
        text-shadow: 1px 1px 2px black;
      }
      canvas {
        display: block; /* Necessary for flex centering */
        /* margin: 0 auto; No longer needed with flexbox */
        background: #222;
        /* Optional: Add a max-width/max-height if needed,
           but the JS logic should handle fitting */
        max-width: 100%;
        max-height: 100%;
      }
      /* Mobile controls container */
      #mobileControls {
        position: fixed;
        bottom: 15px; /* Adjust position slightly */
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        display: grid;
        grid-template-areas:
          ". up ."
          "left down right"; /* Centered layout */
        grid-gap: 10px;
        /* Add some transparency */
        background-color: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 15px;
      }
      #mobileControls button {
        background-color: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.4);
        color: white;
        font-size: 20px; /* Slightly smaller */
        padding: 10px; /* Adjust padding */
        border-radius: 10px;
        width: 50px;  /* Adjust size */
        height: 50px; /* Adjust size */
        outline: none;
        user-select: none; /* Prevent text selection */
        -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        display: flex; /* Center icon */
        align-items: center;
        justify-content: center;
      }
      #upControl { grid-area: up; }
      #downControl { grid-area: down; }
      #leftControl { grid-area: left; }
      #rightControl { grid-area: right; }
    </style>
  </head>
  <body>
    <div id="hud">Score: 0 | Lives: 1</div>
    <!-- Remove fixed width/height attributes -->
    <canvas id="gameCanvas"></canvas>
    <!-- Mobile Control Buttons -->
    <div id="mobileControls">
      <button id="upControl">↑</button>
      <button id="leftControl">←</button>
      <button id="downControl">↓</button>
      <button id="rightControl">→</button>
    </div>
    <script>
      // ---------------- Global Constants & Variables ----------------
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Make game dimensions dynamic
      let gameWidth;
      let gameHeight;
      let numRays; // Number of rays, will be tied to gameWidth

      const FOV = Math.PI / 2.5; // 72° field of view. (Adjusted slightly from 60)
      const MAX_DEPTH = 30; // maximum cast distance

      const MAP_WIDTH = 10;  // grid cells horizontally
      const MAP_HEIGHT = 10; // grid cells vertically

      const pelletImage = new Image();
      //pelletImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVBhXY/iPDTBgYGBgYPBf/+8x/D8fCzAwiAEL/x8MDAxMFISBgeG/ffs2w8jIyAQRBPD///8ZoACU//8/pt///z/DkIGBMRgZGTkAUw0A+a8/U0QKKm0AAAAASUVORK5CYII='; // Embedded blue pellet
      pelletImage.src = 'images/pellet.png'
      
      const redPelletImage = new Image();
      //redPelletImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVBhXY/jPwMAgwsDAwMDw3yTC8P9/BgbGyIAE/P//GRgYpgjC////M/z/nxkYGFhYGN79+w8jIyODCCIAnP//M0ABKP///09hYGBkZAAA/1Y/U96uB+gAAAAASUVORK5CYII='; // Embedded red pellet
      redPelletImage.src = 'images/red_pellet.png'

      const ghostImage = new Image();
      //ghostImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADdSURBVDhPY/z//z8DNwMDw48GQrC9/v0b////Z8AEwOB/AxgYGBh4DRD/x4aBgeH////MAAbA4H8DGBgYGN4FEvAfGxkYGBgY/v//zAAHwOB/AxgYGBgY3gUS8B8bGfj//zMAA7D4/z8DAwPDf4wAAwPD/v37/w8g8R8+fPgPJIHE//79m4GB4T+IiUEkYDD8Z8AEwOB/AxgYGBgY3gUS8B8bGX78+AEjIyODCCIAnP//M0ABKP///w8DAwMjIyODCCIAnP//M0ABKP///w8DAwMjI4PAfwYA8+EN+1Z0Y8IAAAAASUVORK5CYII='; // Embedded simple ghost
      ghostImage.src = 'images/ghost.png'

      const MAX_TAP_TURN_ANGLE_DEG = 45; // Maximum turn angle in degrees
      const MAX_TAP_TURN_ANGLE = (MAX_TAP_TURN_ANGLE_DEG * Math.PI) / 180; // Convert to radians

      // Game state variables
      let maze = [];
      let pelletMap = [];
      let player = { x: 1.5, y: 1.5, angle: 0 };
      let ghost = { x: 0, y: 0, angle: 0 };
      let score = 0;
      let lives = 1;
      let remainingPellets = 0; // Tracks uncollected pellets
      let gameState = "playing"; // "playing" or "banner"
      let bannerMessage = ""; // Message to display on banner
      let bannerStartTime = 0; // Time when banner appears
      let resetGame = true; // Whether to reset score and lives

      let keys = {};

      // ---------------- Utility Functions ----------------
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
      }

      function mod(n, m) {
        return ((n % m) + m) % m;
      }

      function wrappedDiff(a, b, size) {
          let diff = ((a - b) % size + size) % size;
          if (diff > size / 2) diff -= size;
          return diff;
      }

      // ---------------- Maze Generation ----------------
      // (Maze generation functions remain the same)
      function generateMaze() {
        maze = [];
        for (let y = 0; y < MAP_HEIGHT; y++) {
          maze[y] = [];
          for (let x = 0; x < MAP_WIDTH; x++) {
            maze[y][x] = false;
          }
        }

        const startY = getRandomInt(1, MAP_HEIGHT - 1);
        let curX = 0;
        let curY = startY;
        maze[curY][curX] = true;

        while (curX < MAP_WIDTH - 1) {
          let allowed = [];
          if (curX + 3 <= MAP_WIDTH - 1) {
            for (let i = 0; i < 2; i++) allowed.push({ dx: 1, dy: 0 });
          } else {
            allowed.push({ dx: 1, dy: 0 });
          }
          if (curX - 3 >= 1) {
            for (let i = 0; i < 2; i++) allowed.push({ dx: -1, dy: 0 });
          }
          if (curY - 3 >= 1) {
            for (let i = 0; i < 2; i++) allowed.push({ dx: 0, dy: -1 });
          }
          if (curY + 3 <= MAP_HEIGHT - 2) {
            for (let i = 0; i < 2; i++) allowed.push({ dx: 0, dy: 1 });
          }
          if (allowed.length === 0) {
            allowed.push({ dx: 1, dy: 0 });
          }
          const segDir = allowed[getRandomInt(0, allowed.length)];

          for (let step = 0; step < 3; step++) {
            curX += segDir.dx;
            curY += segDir.dy;
            if (curY < 0) curY = 0;
            if (curY >= MAP_HEIGHT) curY = MAP_HEIGHT - 1;
            maze[curY][curX] = true;
            if (curX >= MAP_WIDTH - 1) break;
          }
        }
        while (curY < startY) {
          curY++;
          maze[curY][curX] = true;
        }
        while (curY > startY) {
          curY--;
          maze[curY][curX] = true;
        }
        maze[startY][MAP_WIDTH - 1] = true;

        // Apply symmetry
        makeSymmetric();
      }

      function makeSymmetric() {
        const N = MAP_WIDTH; // MAP_WIDTH = MAP_HEIGHT = 10
        const originalMaze = maze.map(row => row.slice()); // Copy the initial maze
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            // Compute the orbit under D4 symmetries
            const orbitValues = [
              originalMaze[N - 1 - y][x],      // Vertical mirror
              originalMaze[N - 1 - x][y]       // 270° rotation
            ];
            // Set cell to true if any symmetric counterpart is true
            const isCorridor = orbitValues.some(val => val);
            maze[y][x] = isCorridor;
          }
        }
      }
      // ---------------- Pellet Setup ----------------
      // (generatePellets function remains the same)
       function generatePellets() {
        pelletMap = [];
        remainingPellets = 0; // Initialize pellet count
        for (let y = 0; y < MAP_HEIGHT; y++) {
          pelletMap[y] = [];
          for (let x = 0; x < MAP_WIDTH; x++) {
            if (maze[y][x]) {
              pelletMap[y][x] = { collected: false, type: "normal" };
              remainingPellets++; // Increment for each pellet
            } else {
              pelletMap[y][x] = null;
            }
          }
        }
        let redPellets = 0;
        while (redPellets < 1) {
          let rx = getRandomInt(0, MAP_WIDTH);
          let ry = getRandomInt(0, MAP_HEIGHT);
          if (pelletMap[ry][rx] && pelletMap[ry][rx].type === "normal") {
            pelletMap[ry][rx].type = "red";
            redPellets++;
          }
        }
      }

      // ---------------- Initialization ----------------
      function initGame(resetScore = true, resetLives = true) {
        generateMaze();
        generatePellets();
        let pPos = getRandomCorridorCell();
        player.x = pPos.x;
        player.y = pPos.y;
        player.angle = 0;
        let gPos = getRandomCorridorCell();
        ghost.x = gPos.x;
        ghost.y = gPos.y;
        ghost.angle = Math.random() * Math.PI * 2;
        if (resetScore) score = 0;
        if (resetLives) lives = 1;
        updateHUD();
      }

      function getRandomCorridorCell() {
        let x, y;
        do {
          x = getRandomInt(0, MAP_WIDTH);
          y = getRandomInt(0, MAP_HEIGHT);
        } while (!maze[y][x]);
        return { x: x + 0.5, y: y + 0.5 };
      }

      function updateHUD() {
        document.getElementById("hud").innerText = `Score: ${score} | Lives: ${lives}`;
      }

      // ---------------- Canvas Resizing Logic ----------------
      function resizeCanvas() {
          const winW = window.innerWidth;
          const winH = window.innerHeight;
          const isPortrait = winH > winW;

          const minRatio = 4 / 3;
          const maxRatio = 16 / 9;

          let targetRatio;
          let availableH = winH;

          if (isPortrait) {
              targetRatio = minRatio; // Force 4:3 landscape in portrait
              // Leave some space at the bottom (e.g., 10% or fixed pixels for controls)
              availableH = winH * 0.85; // Use 85% of height to leave space
          } else {
              // Landscape: Use window ratio, clamped between 4:3 and 16:9
              const windowRatio = winW / winH;
              targetRatio = Math.max(minRatio, Math.min(maxRatio, windowRatio));
              availableH = winH; // Use full height in landscape
          }

          // Calculate dimensions based on target ratio and available space
          let potentialW = availableH * targetRatio;
          let potentialH = winW / targetRatio;

          let newWidth, newHeight;

          // Choose the dimension set that fits within the available space
          if (potentialW <= winW) {
              // Width calculated from height fits
              newWidth = potentialW;
              newHeight = availableH;
          } else {
              // Height calculated from width fits (or is the only option)
              newWidth = winW;
              newHeight = potentialH;
          }

          // Ensure final dimensions don't exceed the *original* window dimensions
          // (This prevents minor overflows due to the availableH adjustment in portrait)
          newWidth = Math.min(newWidth, winW);
          newHeight = Math.min(newHeight, winH);


          // Apply the calculated dimensions (use integers)
          canvas.width = Math.floor(newWidth);
          canvas.height = Math.floor(newHeight);

          // Update global game dimension variables
          gameWidth = canvas.width;
          gameHeight = canvas.height;
          numRays = gameWidth; // Update number of rays based on new width

          // Optional: Log the new dimensions and ratio for debugging
          // console.log(`Resized to: ${gameWidth}x${gameHeight}, Ratio: ${gameWidth/gameHeight}`);
      }

      // ---------------- Raycasting Engine ----------------
      function castRays() {
          // Use dynamic gameWidth and gameHeight
          ctx.clearRect(0, 0, gameWidth, gameHeight);
          // Draw Floor and Ceiling
          ctx.fillStyle = "#555"; // Ceiling
          ctx.fillRect(0, 0, gameWidth, gameHeight / 2);
          ctx.fillStyle = "#333"; // Floor
          ctx.fillRect(0, gameHeight / 2, gameWidth, gameHeight / 2);

          // Use dynamic numRays
          for (let x = 0; x < numRays; x++) {
              const rayAngle = player.angle - FOV / 2 + (x / numRays) * FOV;
              let rayX = player.x;
              let rayY = player.y;
              const rayDirX = Math.cos(rayAngle);
              const rayDirY = Math.sin(rayAngle);
              let distanceToWall = 0;
              let hitWall = false;
              let hitBoundary = false; // To check if wall hit was on map edge

              while (!hitWall && distanceToWall < MAX_DEPTH) {
                  distanceToWall += 0.05; // Increment distance
                  let testX = Math.floor(mod(rayX + rayDirX * distanceToWall, MAP_WIDTH));
                  let testY = Math.floor(mod(rayY + rayDirY * distanceToWall, MAP_HEIGHT));

                  // Check if the test point is outside the maze boundaries (a wall)
                  if (!maze[testY][testX]) {
                      hitWall = true;

                      // Check if the hit wall is on the boundary of the map
                      // Need to check the *previous* step slightly to determine which wall face was hit
                      let prevTestX = Math.floor(mod(rayX + rayDirX * (distanceToWall - 0.05), MAP_WIDTH));
                      let prevTestY = Math.floor(mod(rayY + rayDirY * (distanceToWall - 0.05), MAP_HEIGHT));

                      // If the x-coord changed, it hit a vertical wall (left/right edge of cell)
                      // If the y-coord changed, it hit a horizontal wall (top/bottom edge of cell)
                      if (testX !== prevTestX) { // Hit vertical wall face
                          hitBoundary = (testX === 0 || testX === MAP_WIDTH - 1);
                      } else if (testY !== prevTestY) { // Hit horizontal wall face
                          hitBoundary = (testY === 0 || testY === MAP_HEIGHT - 1);
                      }
                  }
              }

              // Fish-eye correction
              const correctedDistance = distanceToWall * Math.cos(rayAngle - player.angle);
              // Use dynamic gameHeight
              const lineHeight = Math.floor(gameHeight / correctedDistance);

              // Wall Color based on boundary and distance
              let wallColor;
              let shade = Math.max(0, 255 - correctedDistance * 15); // Adjusted shading factor
              if (hitBoundary) {
                  // Red walls for map boundaries, with distance fading
                  wallColor = `rgb(${shade}, 0, 0)`;
              } else {
                  // Gray walls for internal maze walls, with distance fading
                  wallColor = `rgb(${shade}, ${shade}, ${shade})`;
              }

              ctx.fillStyle = wallColor;
              const lineX = x;
              // Use dynamic gameHeight
              const lineY = (gameHeight - lineHeight) / 2;
              // Draw the wall slice (width is 1 because numRays = gameWidth)
              ctx.fillRect(lineX, lineY, 1, lineHeight);
          }
      }

      // ---------------- Player & Ghost Movement ----------------
      const MOVE_SPEED = 2.5;
      const ROT_SPEED = 2.0;

      function updatePlayer(dt) {
        if (gameState !== "playing") return; // Only update during "playing" state

        // Rotate based on left/right keys
        if (keys.ArrowLeft) player.angle -= ROT_SPEED * dt;
        if (keys.ArrowRight) player.angle += ROT_SPEED * dt;

        // Move based on up/down keys (or always forward if desired)
        let moveDirection = 0;
        if (keys.ArrowUp) moveDirection = 1;
        // if (keys.ArrowDown) moveDirection = -1; // Optional backward movement

        if (moveDirection !== 0) {
          let moveStep = moveDirection * MOVE_SPEED * dt;
          let newX = mod(player.x + Math.cos(player.angle) * moveStep, MAP_WIDTH);
          let newY = mod(player.y + Math.sin(player.angle) * moveStep, MAP_HEIGHT);
          // Collision detection: Check the target cell
          if (maze[Math.floor(newY)][Math.floor(newX)]) {
              player.x = newX;
              player.y = newY;
          } else {
              // Optional: Allow sliding along walls - more complex
              // Try moving only on X axis
              let slideX = mod(player.x + Math.cos(player.angle) * moveStep, MAP_WIDTH);
              if (maze[Math.floor(player.y)][Math.floor(slideX)]) {
                   player.x = slideX;
              } else {
                  // Try moving only on Y axis
                  let slideY = mod(player.y + Math.sin(player.angle) * moveStep, MAP_HEIGHT);
                  if (maze[Math.floor(slideY)][Math.floor(player.x)]) {
                      player.y = slideY;
                  }
              }
          }
        }


        // Pellet collection
        let cellX = Math.floor(player.x);
        let cellY = Math.floor(player.y);
        if (
          pelletMap[cellY] &&
          pelletMap[cellY][cellX] &&
          !showMinimap && // Only collect if minimap is off (original logic)
          !pelletMap[cellY][cellX].collected
        ) {
          pelletMap[cellY][cellX].collected = true;
          if (pelletMap[cellY][cellX].type === "red") lives++;
          score += 10;
          remainingPellets--; // Decrease pellet count
          updateHUD();
          if (remainingPellets === 0) {
            gameState = "banner";
            bannerMessage = `LEVEL CLEAR! Score: ${score}`; // Changed message
            bannerStartTime = performance.now();
            resetGame = false; // Don’t reset score or lives for next level
          }
        }

        // Ghost collision
        if (
          Math.floor(player.x) === Math.floor(ghost.x) &&
          Math.floor(player.y) === Math.floor(ghost.y)
        ) {
          lives--;
          updateHUD();
          if (lives <= 0) {
            gameState = "banner";
            bannerMessage = `GAME OVER | Score: ${score}`;
            bannerStartTime = performance.now();
            resetGame = true; // Reset everything for a new game
          } else {
            // Player hit, but has lives left
            gameState = "banner";
            bannerMessage = `CAUGHT! Lives: ${lives}`; // Changed message
            bannerStartTime = performance.now();
            // Reposition player and ghost after a short delay (handled by banner state)
            // No need to reset score/lives here, just reposition for the current game state
            resetGame = false;
          }
        }
      }

      function updateGhost(dt) {
          if (gameState !== "playing") return;

          // Simple random turning behavior
          if (Math.random() < 0.02) { // Chance to change direction
             ghost.angle = Math.random() * Math.PI * 2;
          }

          const ghostSpeed = MOVE_SPEED * 0.75; // Ghost is slightly slower
          let moveStep = ghostSpeed * dt;
          let newX = mod(ghost.x + Math.cos(ghost.angle) * moveStep, MAP_WIDTH);
          let newY = mod(ghost.y + Math.sin(ghost.angle) * moveStep, MAP_HEIGHT);

          // Check if the next cell is a wall
          if (maze[Math.floor(newY)][Math.floor(newX)]) {
              ghost.x = newX;
              ghost.y = newY;
          } else {
              // Hit a wall, pick a new random direction immediately
              ghost.angle = Math.random() * Math.PI * 2;
          }
      }

      // ---------------- Sprite Drawing ----------------
      function drawSprites() {
          let spritesToDraw = [];
          const RAY_STEP = 0.05; // Step for visibility check

          // Add pellets
          for (let y = 0; y < MAP_HEIGHT; y++) {
              for (let x = 0; x < MAP_WIDTH; x++) {
                  if (pelletMap[y][x] && !pelletMap[y][x].collected) {
                      let spriteX = x + 0.5;
                      let spriteY = y + 0.5;
                      processSprite(spriteX, spriteY, pelletMap[y][x].type === 'red' ? redPelletImage : pelletImage, 0.3, spritesToDraw, 'pellet'); // Smaller pellet size
                  }
              }
          }

          // Add ghost
          processSprite(ghost.x, ghost.y, ghostImage, 0.6, spritesToDraw, 'ghost'); // Slightly smaller ghost size

          // Sort sprites by decreasing distance (farthest first)
          spritesToDraw.sort((a, b) => b.distance - a.distance);

          // Draw sprites
          for (let sprite of spritesToDraw) {
              if (sprite.image.complete && sprite.image.naturalWidth !== 0) {
                  let drawX = sprite.screenX - sprite.screenSize / 2;
                  let drawY;

                  // Adjust vertical position based on type and distance perspective
                  const floorLevel = gameHeight / 2; // Horizon line
                  const perspectiveFactor = gameHeight / (2 * sprite.distance * Math.cos(sprite.relativeAngle)); // Basic perspective scaling

                  if (sprite.type === 'pellet') {
                      // Place pellets closer to the floor
                      drawY = floorLevel + perspectiveFactor * 0.2 - sprite.screenSize / 2; // Adjust 0.2 factor as needed
                  } else { // Ghost
                      // Place ghost slightly above the floor
                      drawY = floorLevel + perspectiveFactor * 0.1 - sprite.screenSize / 1.5; // Adjust 0.1 and 1.5 factors
                  }

                  // Clamp drawY to prevent drawing off-canvas (optional but good practice)
                  drawY = Math.max(0, Math.min(gameHeight - sprite.screenSize, drawY));

                  ctx.drawImage(sprite.image, drawX, drawY, sprite.screenSize, sprite.screenSize);
              }
          }
      }

      function processSprite(spriteX, spriteY, image, baseSize, spritesToDraw, type) {
          const RAY_STEP = 0.05;

          // Calculate wrapped distance and angle to player
          let dx = wrappedDiff(spriteX, player.x, MAP_WIDTH);
          let dy = wrappedDiff(spriteY, player.y, MAP_HEIGHT);
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 0.1) return; // Avoid drawing if too close

          let angleToSprite = Math.atan2(dy, dx);
          // Calculate angle relative to player's view, normalized between -PI and PI
          let relativeAngle = mod(angleToSprite - player.angle + Math.PI, 2 * Math.PI) - Math.PI;

          // Check if sprite is within field of view
          if (Math.abs(relativeAngle) <= FOV / 2 + 0.1) { // Add a small buffer to FOV check
              // Check line of sight (visibility check)
              let isVisible = true;
              const rayDirX = Math.cos(angleToSprite);
              const rayDirY = Math.sin(angleToSprite);
              let currentDist = RAY_STEP; // Start check slightly away from player

              while (currentDist < distance) {
                  let checkX = mod(player.x + rayDirX * currentDist, MAP_WIDTH);
                  let checkY = mod(player.y + rayDirY * currentDist, MAP_HEIGHT);

                  if (!maze[Math.floor(checkY)][Math.floor(checkX)]) {
                      isVisible = false;
                      break; // Hit a wall
                  }
                  currentDist += RAY_STEP;
              }

              if (isVisible) {
                  // Project sprite onto the screen plane
                  // Use dynamic gameWidth
                  const projectionFactor = (gameWidth / 2) / Math.tan(FOV / 2);

                  // Calculate screen X coordinate
                  // Use dynamic gameWidth
                  let screenX = (gameWidth / 2) + Math.tan(relativeAngle) * projectionFactor;

                  // Calculate screen size (adjust for perspective)
                  // Use dynamic gameHeight (or width, depending on preference for scaling reference)
                  let screenSize = (baseSize * projectionFactor) / (distance * Math.cos(relativeAngle)); // Correct for perspective distortion

                  // Add to draw list
                  spritesToDraw.push({
                      screenX: screenX,
                      screenSize: Math.max(1, screenSize), // Ensure minimum size of 1 pixel
                      distance: distance,
                      image: image,
                      type: type, // Store type for vertical positioning
                      relativeAngle: relativeAngle // Store for perspective calc
                  });
              }
          }
      }


      // ---------------- Main Game Loop ----------------
      let lastTime = 0; // Initialize lastTime to 0
      function gameLoop(currentTime) {
        // Initialize lastTime on the first frame
        if (lastTime === 0) {
            lastTime = currentTime;
            requestAnimationFrame(gameLoop);
            return;
        }

        let dt = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // Clamp delta time to prevent large jumps if tab loses focus
        dt = Math.min(dt, 0.1); // Max delta time of 0.1 seconds (10 FPS equivalent)


        if (gameState === "playing") {
            updatePlayer(dt);
            updateGhost(dt);
        }

        castRays();      // Draw walls
        drawSprites();   // Draw sprites (pellets, ghost)
        drawMinimap();   // Draw minimap if applicable

        if (gameState === "banner") {
          drawBanner(bannerMessage);
          // Banner display duration (e.g., 1.5 seconds)
          if (currentTime - bannerStartTime >= 1500) {
            if (resetGame) {
                // Full reset for Game Over
                initGame(true, true); // Reset score and lives
            } else if (lives > 0 && remainingPellets === 0) {
                // Level Clear: Start next level
                initGame(false, false); // Keep score and lives
            } else if (lives > 0) {
                // Caught, but lives remain: Reposition player/ghost
                 let pPos = getRandomCorridorCell();
                 player.x = pPos.x; player.y = pPos.y; player.angle = Math.random() * Math.PI * 2;
                 let gPos;
                 do { gPos = getRandomCorridorCell(); } // Ensure ghost doesn't spawn on player
                 while (Math.floor(gPos.x) === Math.floor(pPos.x) && Math.floor(gPos.y) === Math.floor(pPos.y));
                 ghost.x = gPos.x; ghost.y = gPos.y; ghost.angle = Math.random() * Math.PI * 2;
            }
            // Else (shouldn't happen, but safety): just go back to playing
            gameState = "playing";
          }
        }

        requestAnimationFrame(gameLoop);
      }

      // ---------------- Banner Display ----------------
      function drawBanner(message) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; // Semi-transparent black
        // Use dynamic gameWidth and gameHeight
        ctx.fillRect(0, 0, gameWidth, gameHeight);
        ctx.fillStyle = "white";
        // Adjust font size based on canvas width for readability
        const fontSize = Math.max(24, Math.min(48, Math.floor(gameWidth / 20)));
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; // Center text vertically
        // Use dynamic gameWidth and gameHeight
        ctx.fillText(message, gameWidth / 2, gameHeight / 2);
      }

      // ---------------- Optional 2D Minimap ----------------
      let showMinimap = false;
      function drawMinimap() {
        if (!showMinimap) return;
        // Adjust scale based on canvas size, ensure it doesn't get too big
        const mapAreaSize = Math.min(gameWidth, gameHeight) * 0.25; // Max 25% of smaller dimension
        const scale = Math.floor(mapAreaSize / Math.max(MAP_WIDTH, MAP_HEIGHT));
        const mapOffsetX = 10; // Position from top-left
        const mapOffsetY = 10; // Position from top-left

        if (scale < 1) return; // Don't draw if too small

        ctx.fillStyle = "rgba(50, 50, 50, 0.7)"; // Semi-transparent background
        ctx.fillRect(mapOffsetX - 2, mapOffsetY - 2, MAP_WIDTH * scale + 4, MAP_HEIGHT * scale + 4);

        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            ctx.fillStyle = maze[y][x] ? "#AAA" : "#333"; // Lighter corridor, darker wall
            ctx.fillRect(mapOffsetX + x * scale, mapOffsetY + y * scale, scale, scale);
            // Optional: Draw grid lines
            // ctx.strokeStyle = "#555";
            // ctx.strokeRect(mapOffsetX + x * scale, mapOffsetY + y * scale, scale, scale);

            // Draw pellets on minimap
            if (pelletMap[y][x] && !pelletMap[y][x].collected) {
              ctx.fillStyle = pelletMap[y][x].type === "red" ? "red" : "lightblue";
              ctx.fillRect(
                mapOffsetX + x * scale + scale * 0.3, // Center pellet dot
                mapOffsetY + y * scale + scale * 0.3,
                scale * 0.4, // Smaller dot
                scale * 0.4
              );
            }
          }
        }
        // Draw Player
        ctx.fillStyle = "yellow";
        ctx.fillRect(
          mapOffsetX + player.x * scale - scale * 0.25, // Center player dot
          mapOffsetY + player.y * scale - scale * 0.25,
          scale * 0.5,
          scale * 0.5
        );
        // Draw Ghost
        ctx.fillStyle = "magenta";
        ctx.fillRect(
          mapOffsetX + ghost.x * scale - scale * 0.25, // Center ghost dot
          mapOffsetY + ghost.y * scale - scale * 0.25,
          scale * 0.5,
          scale * 0.5
        );
      }

      // ---------------- Input Handlers ----------------
      // Keyboard Handlers (remain the same)
      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        if (e.key === "m" || e.key === "M") showMinimap = !showMinimap;
        // Prevent default browser behavior for arrow keys if needed
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            e.preventDefault();
        }
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      // Mobile Control Button Handlers (remain the same)
      function addControlListener(buttonId, keyName) {
        const button = document.getElementById(buttonId);
        button.addEventListener("touchstart", (e) => { e.preventDefault(); keys[keyName] = true; }, { passive: false });
        button.addEventListener("mousedown", (e) => { e.preventDefault(); keys[keyName] = true; });
        button.addEventListener("touchend", (e) => { e.preventDefault(); keys[keyName] = false; });
        button.addEventListener("mouseup", (e) => { e.preventDefault(); keys[keyName] = false; });
        button.addEventListener("touchcancel", (e) => { e.preventDefault(); keys[keyName] = false; });
        button.addEventListener("mouseleave", (e) => { /* Keep pressed if mouse leaves while down? Decide behavior. */ if(e.buttons === 1) return; keys[keyName] = false; });
      }
      addControlListener("upControl", "ArrowUp");
      addControlListener("downControl", "ArrowDown"); // Added listener if you implement backward movement
      addControlListener("leftControl", "ArrowLeft");
      addControlListener("rightControl", "ArrowRight");


      // Mobile Tap/Swipe Handlers (Tap-to-turn logic remains the same)
      let touchStartX = null;
      let touchStartY = null;
      const swipeThreshold = 10; // Minimum pixels movement to NOT be a tap

      canvas.addEventListener("touchstart", (e) => {
        if (e.changedTouches && e.changedTouches.length > 0) {
          touchStartX = e.changedTouches[0].pageX;
          touchStartY = e.changedTouches[0].pageY;
        }
        e.preventDefault(); // Prevent scrolling/zooming on canvas touch
      }, { passive: false });

      canvas.addEventListener("touchend", (e) => {
        if (touchStartX === null || touchStartY === null) return; // Ensure start data exists

        if (e.changedTouches && e.changedTouches.length > 0) {
          const touchEndX = e.changedTouches[0].pageX;
          const touchEndY = e.changedTouches[0].pageY;
          const deltaX = touchEndX - touchStartX;
          const deltaY = touchEndY - touchStartY;

          // Check if it was a tap (minimal movement)
          if (Math.abs(deltaX) <= swipeThreshold && Math.abs(deltaY) <= swipeThreshold) {
              // Get the canvas position and dimensions on the screen
              const canvasRect = canvas.getBoundingClientRect();
              // Calculate the tap position relative to the canvas's left edge
              const tapX = touchEndX - canvasRect.left;

              // Ensure the tap was within the horizontal bounds of the canvas
              if (tapX >= 0 && tapX <= canvasRect.width) {
                  // Normalize the tap position: -1 (left edge) to +1 (right edge)
                  const normalizedX = (tapX / canvasRect.width) * 2 - 1;
                  // Calculate the turn amount based on normalized position and max angle
                  const turnAmount = normalizedX * MAX_TAP_TURN_ANGLE;
                  // Apply the turn to the player's angle
                  player.angle += turnAmount;
                  player.angle = mod(player.angle, Math.PI * 2); // Keep angle in range
              }
          }
          // --- You could add swipe detection logic here if needed ---
          // else { // It was likely a swipe
          //    if (Math.abs(deltaX) > Math.abs(deltaY)) { // Horizontal swipe
          //       // keys[deltaX > 0 ? 'ArrowRight' : 'ArrowLeft'] = true; // Or trigger turn
          //    } else { // Vertical swipe
          //       // keys[deltaY > 0 ? 'ArrowDown' : 'ArrowUp'] = true; // Or trigger move
          //    }
          // }
        }
        touchStartX = null;
        touchStartY = null;
        e.preventDefault();
      }, { passive: false });

      // Prevent context menu on long press (mobile)
      canvas.addEventListener('contextmenu', e => e.preventDefault());


      // ---------------- Start the Game ----------------

      // Add the resize event listener
      window.addEventListener('resize', resizeCanvas);

      // Initial setup
      resizeCanvas(); // Set initial canvas size
      initGame();     // Initialize game state

      // Start the game loop
      requestAnimationFrame(gameLoop);

    </script>
  </body>
</html>